# 路径与最短路径指南

## 目标

- 使用变长路径、最短路径算法（Dijkstra/A\*/双向 BFS）
- 结合权重字段优化路径选择

## 基本用法

```ts
const shortest = await db
  .find({ subject: 'user:alice', predicate: 'FRIEND_OF' })
  .variable({ predicate: 'FRIEND_OF', min: 1, max: 4 })
  .to('user:zoe')
  .shortestPath();
```

## 指定权重

```ts
const path = await db
  .find({ subject: 'user:alice', predicate: 'FRIEND_OF' })
  .variable({ predicate: 'FRIEND_OF', min: 1, max: 6 })
  .to('user:zoe')
  .shortestPath({ weight: (edge) => 1 / (edge.edgeProperties?.strength ?? 0.1) });
```

- 权重越小越优；上例代表越强的关系越优先

## A\* 搜索

```ts
const coords = new Map([
  ['user:alice', [121.5, 31.2]],
  ['user:zoe', [121.7, 31.3]],
]);

const path = await db
  .find({ subject: 'user:alice', predicate: 'FRIEND_OF' })
  .variable({ predicate: 'FRIEND_OF', min: 1, max: 6 })
  .to('user:zoe')
  .shortestPath({
    heuristic: (node) => {
      const [lng, lat] = coords.get(node.subject) ?? [0, 0];
      const [targetLng, targetLat] = coords.get('user:zoe') ?? [0, 0];
      return Math.hypot(lng - targetLng, lat - targetLat);
    },
  });
```

## 双向 BFS

- 对于无权图最短路径，可启用双向搜索：

```ts
const path = await db
  .find({ subject: 'user:alice', predicate: 'FRIEND_OF' })
  .variable({ predicate: 'FRIEND_OF', min: 1, max: 4 })
  .to('user:bob')
  .shortestPath({ strategy: 'bidirectional' });
```

## 所有路径

```ts
const all = await db
  .find({ subject: 'user:alice', predicate: 'FRIEND_OF' })
  .variable({ predicate: 'FRIEND_OF', min: 1, max: 3 })
  .to('user:eva')
  .allPaths({ limit: 10 });
```

## 常见问题

| 现象       | 原因              | 解决                               |
| ---------- | ----------------- | ---------------------------------- |
| 找不到路径 | 无连接或 max 太小 | 提高 `max` 或拓宽谓词集合          |
| 性能慢     | 搜索范围过大      | 调整权重、启用 heuristic、缩小范围 |
| 路径重复   | 图存在环          | 使用 `takeUntil` 或 `distinct()`   |

## 延伸阅读

- [示例 03 · 查询与联想](03-查询与联想-示例.md)
- [图算法库使用指南](图算法库使用指南.md)
