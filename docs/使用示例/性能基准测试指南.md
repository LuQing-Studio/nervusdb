# SynapseDB 性能基准测试指南

## 概述

SynapseDB 性能基准测试框架提供了完整的性能分析、回归检测和报告生成功能。支持多种输出格式、内存泄漏检测、以及自动化的性能回归分析，帮助开发者监控和优化数据库性能。

## 核心组件

### 1. 基准测试管理器

```typescript
import { BenchmarkManager, createBenchmarkManager, synapseDBCoreSuite } from '@/benchmark';

// 创建基准测试管理器
const manager = createBenchmarkManager();

// 运行单个测试套件
const results = await manager.runSuite(synapseDBCoreSuite);

// 运行完整基准测试
const { report, outputs } = await manager.benchmark({
  suites: [synapseDBCoreSuite],
  outputFormats: ['console', 'html', 'json'],
  outputDir: './benchmark-reports',
});

console.log('基准测试完成:', report.summary);
```

### 2. 测试运行器

```typescript
import { BenchmarkRunnerImpl, PerformanceMonitorImpl } from '@/benchmark/runner';

// 创建性能监控器
const monitor = new PerformanceMonitorImpl();

// 监控内存使用
monitor.startMemoryMonitoring();
// 执行一些操作...
const memoryStats = monitor.getMemoryStats();
console.log('内存统计:', memoryStats);

// 创建基准测试运行器
const runner = new BenchmarkRunnerImpl();

// 运行单个测试
const testResult = await runner.runTest({
  name: '自定义性能测试',
  description: '测试特定功能性能',
  test: async (config) => {
    // 测试实现
    const startTime = performance.now();

    // 执行被测试代码
    for (let i = 0; i < 1000; i++) {
      // 模拟操作
    }

    const executionTime = performance.now() - startTime;

    return {
      name: '自定义性能测试',
      executionTime,
      memoryUsage: process.memoryUsage().heapUsed,
      operations: 1000,
      operationsPerSecond: (1000 / executionTime) * 1000,
      averageLatency: executionTime / 1000,
      minLatency: 0,
      maxLatency: 0,
      p95Latency: 0,
      p99Latency: 0,
      dataSize: 1000,
      timestamp: new Date(),
    };
  },
});
```

## 命令行工具使用

### 运行完整基准测试

```bash
# 运行所有模块的基准测试
pnpm benchmark

# 指定输出格式和目录
pnpm benchmark -- --format html,json,csv --output ./reports

# 不显示控制台输出
pnpm benchmark -- --no-console --format html,json
```

### 运行特定模块测试

```bash
# SynapseDB 核心功能测试
pnpm benchmark:core

# 全文搜索引擎测试
pnpm benchmark:search

# 图算法库测试
pnpm benchmark:graph

# 空间几何计算测试
pnpm benchmark:spatial
```

### 性能回归检测

```bash
# 基于基线报告检测性能回归
pnpm benchmark regression --baseline ./reports/baseline.json --threshold 10

# 设置更严格的回归阈值
pnpm benchmark regression --baseline ./reports/baseline.json --threshold 5
```

### 内存泄漏检测

```bash
# 运行内存泄漏检测
pnpm benchmark memory-leak

# 自定义参数
pnpm benchmark memory-leak --iterations 200 --operations 2000 --threshold 20971520

# 强制垃圾回收（需要 --expose-gc 启动参数）
node --expose-gc ./dist/cli/benchmark.js memory-leak --force-gc
```

## 内置测试套件

### 1. SynapseDB 核心功能套件

```typescript
import { synapseDBCoreSuite } from '@/benchmark/suites';

// 包含的测试项目：
// - 三元组插入性能
// - 三元组查询性能
// - 批量插入性能
// - 索引构建性能
// - 属性存储性能
// - WAL 写入性能
// - 压实操作性能

const coreResults = await manager.runSuite(synapseDBCoreSuite);
console.log('核心功能测试结果:', coreResults);
```

### 2. 全文搜索引擎套件

```typescript
import { fullTextSearchSuite } from '@/benchmark/suites';

// 包含的测试项目：
// - 文档索引性能
// - 搜索查询性能
// - 布尔查询性能
// - 模糊搜索性能
// - 分析器性能

const searchResults = await manager.runSuite(fullTextSearchSuite);
console.log('全文搜索测试结果:', searchResults);
```

### 3. 图算法库套件

```typescript
import { graphAlgorithmsSuite } from '@/benchmark/suites';

// 包含的测试项目：
// - PageRank 算法性能
// - 社区发现算法性能
// - 最短路径算法性能
// - 中心性算法性能
// - 相似度计算性能

const graphResults = await manager.runSuite(graphAlgorithmsSuite);
console.log('图算法测试结果:', graphResults);
```

### 4. 空间几何计算套件

```typescript
import { spatialGeometrySuite } from '@/benchmark/suites';

// 包含的测试项目：
// - 距离计算性能
// - 几何相交检测性能
// - 缓冲区生成性能
// - 面积计算性能
// - 空间索引性能

const spatialResults = await manager.runSuite(spatialGeometrySuite);
console.log('空间计算测试结果:', spatialResults);
```

## 自定义测试套件

### 创建自定义测试

```typescript
import { BenchmarkTest, BenchmarkSuite } from '@/benchmark/types';

// 定义单个测试
const customTest: BenchmarkTest = {
  name: '自定义数据库查询测试',
  description: '测试复杂查询场景的性能',
  test: async (config) => {
    const startTime = performance.now();

    // 初始化测试数据
    const db = await SynapseDB.open(':memory:');

    // 添加测试数据
    for (let i = 0; i < 5000; i++) {
      db.addFact({
        subject: `entity_${i}`,
        predicate: 'hasProperty',
        object: `value_${i % 100}`,
      });
    }

    await db.flush();

    // 执行查询测试
    const queryStart = performance.now();
    const results = db.find({ predicate: 'hasProperty' }).all();
    const queryTime = performance.now() - queryStart;

    const totalTime = performance.now() - startTime;

    await db.close();

    return {
      name: '自定义数据库查询测试',
      description: '测试复杂查询场景的性能',
      executionTime: totalTime,
      memoryUsage: process.memoryUsage().heapUsed,
      operations: results.length,
      operationsPerSecond: (results.length / queryTime) * 1000,
      averageLatency: queryTime / results.length,
      minLatency: 0,
      maxLatency: queryTime,
      p95Latency: queryTime * 0.95,
      p99Latency: queryTime * 0.99,
      dataSize: 5000,
      timestamp: new Date(),
      metadata: {
        queryTime,
        resultCount: results.length,
        dataSize: 5000,
      },
    };
  },
};

// 创建测试套件
const customSuite: BenchmarkSuite = {
  name: '自定义测试套件',
  description: '针对特定业务场景的性能测试',
  benchmarks: [customTest],
  config: {
    warmupRuns: 2,
    runs: 5,
    timeout: 30000,
  },
};

// 运行自定义测试套件
const customResults = await manager.runSuite(customSuite);
```

### 批量测试场景

```typescript
// 创建数据密集型测试
const dataIntensiveTests: BenchmarkTest[] = [
  {
    name: '大量三元组插入',
    test: async () => {
      const db = await SynapseDB.open(':memory:');
      const startTime = performance.now();

      // 插入100万个三元组
      for (let i = 0; i < 1000000; i++) {
        db.addFact({
          subject: `s_${i}`,
          predicate: 'relates_to',
          object: `o_${i % 10000}`,
        });

        // 每10000条记录刷新一次
        if (i % 10000 === 0) {
          await db.flush();
        }
      }

      await db.flush();
      const executionTime = performance.now() - startTime;

      await db.close();

      return {
        name: '大量三元组插入',
        executionTime,
        memoryUsage: process.memoryUsage().heapUsed,
        operations: 1000000,
        operationsPerSecond: (1000000 / executionTime) * 1000,
        averageLatency: executionTime / 1000000,
        minLatency: 0,
        maxLatency: 0,
        p95Latency: 0,
        p99Latency: 0,
        dataSize: 1000000,
        timestamp: new Date(),
      };
    },
  },

  {
    name: '复杂查询性能',
    test: async () => {
      // 类似的实现...
    },
  },
];
```

## 报告生成和分析

### HTML 报告

HTML 报告包含交互式图表和详细的性能分析：

```typescript
// 生成 HTML 报告
const { outputs } = await manager.benchmark({
  suites: [synapseDBCoreSuite],
  outputFormats: ['html'],
  outputDir: './reports',
});

// HTML 报告特性：
// - 交互式性能图表（使用 Chart.js）
// - 内存使用趋势图
// - 操作吞吐量对比
// - 延迟分布直方图
// - 性能建议和优化提示
```

### JSON 报告

JSON 格式便于程序化处理和集成到 CI/CD 流水线：

```typescript
// 解析 JSON 报告
const report = JSON.parse(await fs.readFile('./reports/benchmark-report.json', 'utf8'));

console.log('测试摘要:', report.summary);
console.log('环境信息:', report.environment);
console.log('详细结果:', report.results);

// 提取关键指标
const coreResults = report.results.find((r) => r.suiteName === 'SynapseDB Core');
const insertionTest = coreResults.results.find((r) => r.name.includes('插入'));

console.log(`插入性能: ${insertionTest.operationsPerSecond.toFixed(0)} ops/sec`);
console.log(`平均延迟: ${insertionTest.averageLatency.toFixed(2)}ms`);
```

### CSV 报告

CSV 格式适合导入到电子表格进行进一步分析：

```bash
# CSV 报告包含字段：
# - 测试名称
# - 执行时间
# - 内存使用
# - 操作数量
# - 每秒操作数
# - 平均延迟
# - P95/P99 延迟
# - 数据大小
# - 时间戳

# 在 Excel 或 Google Sheets 中打开进行趋势分析
```

## 性能回归检测

### 基线建立

```bash
# 首次运行建立基线
pnpm benchmark -- --format json --output ./baselines

# 重命名为基线文件
mv ./baselines/benchmark-report-*.json ./baselines/baseline.json
```

### 回归检测配置

```typescript
// 配置回归检测
const regressionResults = await manager.runRegressionTest(baselineReport, {
  regressionThreshold: 10, // 10% 性能退化阈值
  improvementThreshold: 5, // 5% 性能改进阈值
  significance: 0.05, // 统计显著性水平
  minSampleSize: 3, // 最小样本数
});

// 分析回归结果
const failedRegressions = regressionResults.filter((r) => !r.passed);

if (failedRegressions.length > 0) {
  console.log('检测到性能回归:');

  failedRegressions.forEach((regression) => {
    console.log(`❌ ${regression.testName}:`);
    console.log(`  指标: ${regression.metric}`);
    console.log(`  变化: ${regression.changePercent.toFixed(2)}%`);
    console.log(`  当前: ${regression.currentValue.toFixed(2)}`);
    console.log(`  基线: ${regression.baselineValue.toFixed(2)}`);
  });
}
```

### CI/CD 集成

```yaml
# GitHub Actions 示例
name: Performance Regression Test

on: [push, pull_request]

jobs:
  benchmark:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: pnpm install

      - name: Run benchmarks
        run: pnpm benchmark -- --format json --output ./reports

      - name: Check for regressions
        run: |
          if [ -f ./baselines/baseline.json ]; then
            pnpm benchmark regression \
              --baseline ./baselines/baseline.json \
              --threshold 15 \
              --output ./reports
          else
            echo "No baseline found, skipping regression test"
          fi

      - name: Upload reports
        uses: actions/upload-artifact@v3
        with:
          name: benchmark-reports
          path: ./reports/
```

## 内存泄漏检测

### 基础检测

```typescript
// 内存泄漏检测实现
class MemoryLeakDetector {
  private memoryProgression: number[] = [];

  async detectLeaks(options: {
    iterations: number;
    operationsPerIteration: number;
    threshold: number;
  }) {
    const { iterations, operationsPerIteration, threshold } = options;

    // 强制垃圾回收（如果可用）
    if (global.gc) {
      global.gc();
    }

    const initialMemory = process.memoryUsage().heapUsed;
    this.memoryProgression.push(initialMemory);

    // 执行测试迭代
    for (let i = 0; i < iterations; i++) {
      await this.runIteration(operationsPerIteration);

      // 强制垃圾回收
      if (global.gc) {
        global.gc();
      }

      const currentMemory = process.memoryUsage().heapUsed;
      this.memoryProgression.push(currentMemory);
    }

    // 分析内存增长趋势
    const finalMemory = this.memoryProgression[this.memoryProgression.length - 1];
    const memoryGrowth = finalMemory - initialMemory;

    return {
      hasLeak: memoryGrowth > threshold,
      memoryGrowth,
      growthTrend: this.analyzeGrowthTrend(),
      progression: this.memoryProgression,
    };
  }

  private async runIteration(operations: number) {
    // 模拟内存操作
    const db = await SynapseDB.open(':memory:');

    for (let i = 0; i < operations; i++) {
      db.addFact({
        subject: `temp_${i}`,
        predicate: 'test',
        object: `value_${i}`,
      });
    }

    await db.flush();
    await db.close();
  }

  private analyzeGrowthTrend(): 'increasing' | 'stable' | 'decreasing' {
    if (this.memoryProgression.length < 10) return 'stable';

    const mid = Math.floor(this.memoryProgression.length / 2);
    const firstHalf = this.memoryProgression.slice(0, mid);
    const secondHalf = this.memoryProgression.slice(mid);

    const firstAvg = firstHalf.reduce((sum, val) => sum + val, 0) / firstHalf.length;
    const secondAvg = secondHalf.reduce((sum, val) => sum + val, 0) / secondHalf.length;

    if (secondAvg > firstAvg * 1.1) return 'increasing';
    if (secondAvg < firstAvg * 0.9) return 'decreasing';
    return 'stable';
  }
}
```

### 使用命令行检测

```bash
# 基础内存泄漏检测
pnpm benchmark memory-leak

# 自定义参数检测
pnpm benchmark memory-leak \
  --iterations 100 \
  --operations 1000 \
  --threshold 10485760

# 启用垃圾回收强制执行
node --expose-gc ./dist/cli/benchmark.js memory-leak --force-gc
```

## 性能优化建议

### 基于测试结果的优化

```typescript
// 性能分析和建议生成
class PerformanceAnalyzer {
  generateRecommendations(results: BenchmarkResult[]): string[] {
    const recommendations: string[] = [];

    results.forEach((result) => {
      // 内存使用分析
      if (result.memoryUsage > 100 * 1024 * 1024) {
        // 100MB
        recommendations.push(
          `${result.name}: 内存使用过高 (${(result.memoryUsage / 1024 / 1024).toFixed(1)}MB)，考虑优化数据结构或增加垃圾回收`,
        );
      }

      // 执行时间分析
      if (result.averageLatency > 100) {
        // 100ms
        recommendations.push(
          `${result.name}: 平均延迟过高 (${result.averageLatency.toFixed(2)}ms)，建议检查算法复杂度和I/O操作`,
        );
      }

      // 吞吐量分析
      if (result.operationsPerSecond < 1000) {
        recommendations.push(
          `${result.name}: 吞吐量较低 (${result.operationsPerSecond.toFixed(0)} ops/sec)，考虑批处理优化或并行化`,
        );
      }

      // P99 延迟分析
      if (result.p99Latency > result.averageLatency * 5) {
        recommendations.push(`${result.name}: P99延迟波动大，可能存在性能热点或资源竞争`);
      }
    });

    return recommendations;
  }
}

// 使用分析器
const analyzer = new PerformanceAnalyzer();
const recommendations = analyzer.generateRecommendations(benchmarkResults);

console.log('性能优化建议:');
recommendations.forEach((rec, index) => {
  console.log(`${index + 1}. ${rec}`);
});
```

### 常见性能模式

```typescript
// 批处理优化模式
async function batchOptimizedInsert(db: SynapseDB, facts: Fact[]) {
  const batchSize = 1000;

  for (let i = 0; i < facts.length; i += batchSize) {
    const batch = facts.slice(i, i + batchSize);

    // 开始批次
    db.beginBatch();

    try {
      // 批量添加
      batch.forEach((fact) => db.addFact(fact));

      // 提交批次
      await db.commitBatch();
    } catch (error) {
      // 回滚批次
      await db.abortBatch();
      throw error;
    }
  }
}

// 内存优化模式
async function memoryEfficientQuery(db: SynapseDB, criteria: any) {
  const iterator = db.find(criteria).iterator({ batchSize: 100 });

  const results = [];
  for await (const batch of iterator) {
    // 处理批次
    results.push(...batch);

    // 定期垃圾回收
    if (results.length % 1000 === 0 && global.gc) {
      global.gc();
    }
  }

  return results;
}
```

## 最佳实践

### 1. 测试环境一致性

```typescript
// 确保测试环境一致
const environmentInfo = {
  nodeVersion: process.version,
  platform: process.platform,
  arch: process.arch,
  cpuInfo: require('os').cpus()[0],
  totalMemory: require('os').totalmem(),
  freeMemory: require('os').freemem(),
};

console.log('测试环境:', environmentInfo);
```

### 2. 测试数据标准化

```typescript
// 使用确定性测试数据
class TestDataGenerator {
  constructor(private seed: number = 42) {}

  generateFacts(count: number): Fact[] {
    const facts: Fact[] = [];

    for (let i = 0; i < count; i++) {
      facts.push({
        subject: `entity_${i}`,
        predicate: this.getRandomPredicate(i),
        object: `value_${i % 100}`,
      });
    }

    return facts;
  }

  private getRandomPredicate(index: number): string {
    const predicates = ['hasProperty', 'relatesTo', 'contains', 'dependsOn'];
    return predicates[index % predicates.length];
  }
}
```

### 3. 结果验证

```typescript
// 验证基准测试结果的有效性
class ResultValidator {
  validate(result: BenchmarkResult): boolean {
    // 基本有效性检查
    if (result.executionTime <= 0) return false;
    if (result.operations <= 0) return false;
    if (result.operationsPerSecond <= 0) return false;

    // 逻辑一致性检查
    const expectedOpsPerSec = (result.operations / result.executionTime) * 1000;
    const deviation = Math.abs(result.operationsPerSecond - expectedOpsPerSec) / expectedOpsPerSec;

    if (deviation > 0.01) {
      // 1% 偏差容忍度
      console.warn(`性能指标不一致: ${result.name}`);
      return false;
    }

    return true;
  }
}
```

### 4. 持续监控

```typescript
// 设置性能监控告警
class PerformanceMonitor {
  private thresholds = {
    maxExecutionTime: 5000, // 5秒
    maxMemoryUsage: 500 * 1024 * 1024, // 500MB
    minOperationsPerSecond: 100, // 100 ops/sec
  };

  checkThresholds(result: BenchmarkResult): string[] {
    const violations: string[] = [];

    if (result.executionTime > this.thresholds.maxExecutionTime) {
      violations.push(`执行时间超限: ${result.executionTime}ms`);
    }

    if (result.memoryUsage > this.thresholds.maxMemoryUsage) {
      violations.push(`内存使用超限: ${(result.memoryUsage / 1024 / 1024).toFixed(1)}MB`);
    }

    if (result.operationsPerSecond < this.thresholds.minOperationsPerSecond) {
      violations.push(`吞吐量过低: ${result.operationsPerSecond.toFixed(0)} ops/sec`);
    }

    return violations;
  }
}
```

## 故障排除

### 常见问题

1. **测试超时**
   - 检查 `timeout` 配置
   - 减少测试数据量
   - 优化测试逻辑

2. **内存不足**
   - 增加 Node.js 堆内存限制：`node --max-old-space-size=4096`
   - 使用批处理减少内存占用
   - 启用垃圾回收：`node --expose-gc`

3. **结果不稳定**
   - 增加预热运行次数
   - 增加测试运行次数
   - 确保测试环境一致性

### 调试技巧

```typescript
// 启用详细日志
const debugResults = await manager.benchmark({
  suites: [synapseDBCoreSuite],
  outputFormats: ['console'],
  outputDir: './reports',
  debug: true, // 启用调试模式
});

// 单独运行有问题的测试
const problematicTest = synapseDBCoreSuite.benchmarks.find((test) => test.name === '问题测试');

const result = await runner.runTest(problematicTest, {
  runs: 1,
  warmupRuns: 0,
  debug: true,
});

console.log('调试结果:', result);
```

通过这个详细的性能基准测试指南，你可以充分利用 SynapseDB 的基准测试框架，进行全面的性能分析、回归检测和优化工作，确保数据库在各种场景下的稳定性能。
