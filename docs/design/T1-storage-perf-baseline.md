# T1: Core 写读性能基线（索引收口 + 事务/表句柄复用 + 字符串缓存）

## 1. Context

- 目标是“图数据库界的 SQLite”：默认配置下就要够快、够稳，不靠用户调参。
- 旧实现的主要浪费来自两类无意义成本：
  - **写放大**：为覆盖查询模式维护过多索引表，插入一条 triple 需要写多张表。
  - **固定开销**：查询/写入路径频繁 `begin_read/open_table`，以及热字符串反复 B-Tree 查找。

## 2. Goals

- 写路径达到“嵌入式可用”的吞吐下限（目标 ≥ 200K triples/sec；以普通 SSD 为基准）。
- 常见点查（`S??` / `??O` / `P??`）保持 `O(log N)`，且实现不引入额外复杂度。
- 不引入全局缓存/后台线程/复杂一致性协议：简单、可预测、可回滚。

## 3. Non-Goals

- 不做“把整个字典搬到内存”的镜像缓存（一致性与内存上限会把项目拖进泥潭）。
- 不新增“更多索引”来掩盖设计问题：先把数据结构收口，再谈优化。

## 4. Solution

### 4.1 索引收口：只保留三张表

- 保留：
  - `SPO`
  - `POS`
  - `OSP`
- 代价/收益：
  - 写入每条 triple 固定写 3 次（不含字典/属性表），写放大显著下降。
  - 覆盖 `S?? / ??O / P??` 等主要模式；更稀有的模式接受退化（1.0 不为少数特例堆复杂度）。

### 4.2 写事务内复用 table handles

- 在单个写事务上下文中缓存 `Table` 句柄：
  - 避免每次插入/属性写入都重复 `open_table()`。

### 4.3 字符串缓存：真 LRU

- `WriteTableHandles` 内维护字符串 LRU：
  - 热字符串命中不再触发 `str_to_id` 的 B-Tree 查找。
  - 容量有硬上限（沿用现有 `STRING_CACHE_LIMIT`），避免内存失控。

### 4.4 读事务/表句柄缓存（带失效）

- 查询路径复用 `ReadTransaction + ReadOnlyTable`。
- 关键点：**写入 commit 后必须失效读缓存**，避免读到旧 snapshot。

## 5. Testing Strategy

- 单元测试：
  - 插入/查询/属性读写/事务语义（已有测试覆盖）。
- 基准回归：
  - 以 `docs/perf/PERFORMANCE_ANALYSIS.md` 记录的数字为基线，要求“无回退”。

## 6. Risks

- 索引减少可能导致少数查询模式退化：必须把“核心查询路径”定义清楚，避免以后又把特例堆回去。
- 读缓存失效如果做错会出现难查的旧读：必须把失效点固定在 `commit`，不要搞隐式魔法。
