# 路径遍历操作

<cite>
**本文档引用的文件**
- [queryBuilder.ts](file://src/query/queryBuilder.ts)
- [variable.ts](file://src/query/path/variable.ts)
- [bidirectional.ts](file://src/query/path/bidirectional.ts)
- [astar.ts](file://src/query/path/astar.ts)
- [synapseDb.ts](file://src/synapseDb.ts)
- [minHeap.ts](file://src/utils/minHeap.ts)
</cite>

## 目录
1. [路径遍历机制概述](#路径遍历机制概述)
2. [followPath方法实现原理](#followpath方法实现原理)
3. [VariablePathBuilder与变长路径查询](#variablepathbuilder与变长路径查询)
4. [双向最短路径查找](#双向最短路径查找)
5. [A*加权路径查找算法](#a加权路径查找算法)
6. [唯一性约束与循环检测](#唯一性约束与循环检测)
7. [性能优化策略](#性能优化策略)

## 路径遍历机制概述

SynapseDB提供了多层次的路径遍历能力，支持从简单的固定跳数遍历到复杂的启发式搜索。系统通过QueryBuilder构建链式查询，结合BFS、双向BFS和A*等算法实现高效的图遍历。核心功能包括变长路径查询、最短路径查找和加权路径搜索，满足不同场景下的图分析需求。

## followPath方法实现原理

`followPath`方法实现了基于广度优先搜索（BFS）的变长路径查询机制，支持[min..max]跳数范围的同谓词遍历。该方法从当前前沿节点集出发，按层扩展搜索空间，在指定深度范围内收集符合条件的三元组。

```mermaid
flowchart TD
Start([开始]) --> ValidateInput["验证输入参数"]
ValidateInput --> CheckFrontier{"前沿节点为空?"}
CheckFrontier --> |是| ReturnEmpty["返回空结果"]
CheckFrontier --> |否| GetPredicateId["获取谓词ID"]
GetPredicateId --> InitState["初始化状态变量"]
InitState --> WhileLoop{"深度 < 最大值 且 前沿非空?"}
WhileLoop --> |否| BuildResult["构建结果"]
WhileLoop --> |是| IncrementDepth["深度+1"]
IncrementDepth --> ProcessCurrentLayer["处理当前层前沿"]
ProcessCurrentLayer --> ForEachNode["遍历每个节点"]
ForEachNode --> CheckVisited{"已访问?"}
CheckVisited --> |是| SkipNode["跳过"]
CheckVisited --> |否| MarkVisited["标记为已访问"]
MarkVisited --> QueryMatches["查询匹配三元组"]
QueryMatches --> ForEachMatch["遍历每个匹配"]
ForEachMatch --> CheckDepth{"深度 >= 最小值?"}
CheckDepth --> |是| CollectTriple["收集三元组"]
CheckDepth --> |否| ContinueLoop["继续"]
CollectTriple --> UpdateNextFrontier["更新下一层前沿"]
ContinueLoop --> UpdateNextFrontier
UpdateNextFrontier --> EndOfLayer
EndOfLayer --> WhileLoop
BuildResult --> ReturnResult["返回QueryBuilder"]
```

**Diagram sources**
- [queryBuilder.ts](file://src/query/queryBuilder.ts#L707-L775)

**Section sources**
- [queryBuilder.ts](file://src/query/queryBuilder.ts#L707-L775)

## VariablePathBuilder与变长路径查询

`variablePath`方法返回`VariablePathBuilder`实例，支持更复杂的路径模式匹配。该构建器允许设置最小/最大跳数、唯一性约束和遍历方向，提供灵活的路径查询能力。

```mermaid
classDiagram
class VariablePathBuilder {
+store : PersistentStore
+startNodes : Set<number>
+predicateId : number
+options : VariablePathOptions
+all(target? : number) : PathResult[]
+shortest(target : number) : PathResult | null
-neighbors(nodeId : number, dir : Direction) : FactRecord[]
-nextNode(rec : FactRecord, from : number, dir : Direction) : number
}
class PathResult {
+edges : PathEdge[]
+length : number
+startId : number
+endId : number
}
class PathEdge {
+record : FactRecord
+direction : Direction
}
class VariablePathOptions {
+min? : number
+max : number
+uniqueness? : Uniqueness
+direction? : Direction
}
VariablePathBuilder --> PathResult : "生成"
VariablePathBuilder --> PathEdge : "包含"
VariablePathBuilder --> VariablePathOptions : "使用"
```

**Diagram sources**
- [variable.ts](file://src/query/path/variable.ts#L0-L110)

**Section sources**
- [variable.ts](file://src/query/path/variable.ts#L0-L110)
- [queryBuilder.ts](file://src/query/queryBuilder.ts#L56-L70)

## 双向最短路径查找

双向BFS算法通过同时从起点和终点进行搜索，显著减少搜索空间。当两个搜索前沿相遇时，即可构建完整路径。相比单向BFS，时间复杂度从O(b^d)降低到O(b^(d/2))，其中b为分支因子，d为深度。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Forward as "前向搜索"
participant Backward as "后向搜索"
participant Intersection as "交点检测"
Client->>Forward : 初始化起点队列
Client->>Backward : 初始化终点队列
loop 搜索过程
Forward->>Forward : 扩展当前层
Backward->>Backward : 扩展当前层
Forward->>Intersection : 提交前向访问记录
Backward->>Intersection : 提交后向访问记录
Intersection->>Intersection : 检查交集
alt 找到交点
Intersection-->>Client : 返回路径
break
end
end
```

**Diagram sources**
- [bidirectional.ts](file://src/query/path/bidirectional.ts#L0-L301)
- [synapseDb.ts](file://src/synapseDb.ts#L580-L743)

**Section sources**
- [bidirectional.ts](file://src/query/path/bidirectional.ts#L0-L301)
- [synapseDb.ts](file://src/synapseDb.ts#L580-L743)

## A*加权路径查找算法

A*算法结合了Dijkstra算法的准确性和贪心最佳优先搜索的效率，使用启发式函数估算从当前节点到目标的距离。系统支持多种启发式函数类型，并可通过权重因子调节启发式的影响程度。

```mermaid
classDiagram
class AStarPathBuilder {
+store : PersistentStore
+startNodes : Set<number>
+targetNodes : Set<number>
+predicateId : number
+options : VariablePathOptions
+heuristicOptions : HeuristicOptions
+shortestPath() : PathResult | null
+allPaths() : PathResult[]
-getNeighbors(nodeId : number, direction : Direction) : FactRecord[]
-getNextNode(record : FactRecord, currentNode : number, direction : Direction) : number
-heuristic(fromNodeId : number, targetNodeIds : Set<number>) : number
-reconstructPath(goalNode : AStarNode) : PathResult
}
class AStarNode {
+nodeId : number
+gScore : number
+fScore : number
+parent? : AStarNode
+edge? : PathEdge
+visitedNodes : Set<number>
+visitedEdges : Set<string>
}
class HeuristicOptions {
+type : 'manhattan' | 'euclidean' | 'hop' | 'custom'
+customHeuristic? : (from : number, to : number, store : PersistentStore) => number
+weight? : number
}
AStarPathBuilder --> AStarNode : "使用"
AStarPathBuilder --> HeuristicOptions : "配置"
AStarPathBuilder --> PathResult : "输出"
```

**Diagram sources**
- [astar.ts](file://src/query/path/astar.ts#L0-L344)
- [synapseDb.ts](file://src/synapseDb.ts#L746-L802)

**Section sources**
- [astar.ts](file://src/query/path/astar.ts#L0-L344)
- [synapseDb.ts](file://src/synapseDb.ts#L746-L802)

## 唯一性约束与循环检测

系统提供三种唯一性约束模式：NODE（节点不重复）、EDGE（边不重复）和NONE（无约束）。这些约束在路径搜索过程中用于防止循环路径，确保结果的合理性。

```mermaid
flowchart TD
Start([开始]) --> CheckUniqueness["检查唯一性约束"]
CheckUniqueness --> NodeUnique{"NODE约束?"}
NodeUnique --> |是| CheckNodeVisited{"节点已访问?"}
NodeUnique --> |否| EdgeUnique["检查边约束"]
CheckNodeVisited --> |是| SkipNode["跳过该节点"]
CheckNodeVisited --> |否| AddToPath["添加到路径"]
EdgeUnique --> |是| CheckEdgeVisited{"边已访问?"}
EdgeUnique --> |否| AddToPath
CheckEdgeVisited --> |是| SkipEdge["跳过该边"]
CheckEdgeVisited --> |否| AddToPath
AddToPath --> ContinueSearch["继续搜索"]
SkipNode --> ContinueSearch
SkipEdge --> ContinueSearch
```

**Section sources**
- [variable.ts](file://src/query/path/variable.ts#L0-L110)
- [bidirectional.ts](file://src/query/path/bidirectional.ts#L0-L301)
- [astar.ts](file://src/query/path/astar.ts#L0-L344)

## 性能优化策略

系统采用多种技术优化路径查询性能：
1. 使用MinHeap实现Dijkstra算法的优先队列，将插入和删除操作优化至O(log n)
2. 在双向BFS中缓存邻居查询结果，避免重复查询
3. 选择较小的一侧前沿进行扩展，提高搜索效率
4. 启发式函数支持自定义实现，可根据具体场景优化搜索行为

```mermaid
graph TB
subgraph "数据结构优化"
MinHeap["最小堆<br>O(log n)操作"]
Cache["查询结果缓存"]
end
subgraph "算法优化"
Bidirectional["双向搜索"]
Heuristic["启发式评估"]
EarlyTermination["提前终止"]
end
subgraph "执行策略"
SmallSide["选择小侧扩展"]
WeightedSearch["加权路径搜索"]
end
MinHeap --> Dijkstra
Cache --> Bidirectional
Bidirectional --> Performance
Heuristic --> AStar
EarlyTermination --> Performance
SmallSide --> Bidirectional
WeightedSearch --> Dijkstra
AStar --> Performance
Dijkstra --> Performance
```

**Diagram sources**
- [minHeap.ts](file://src/utils/minHeap.ts#L0-L114)
- [astar.ts](file://src/query/path/astar.ts#L0-L344)
- [bidirectional.ts](file://src/query/path/bidirectional.ts#L0-L301)

**Section sources**
- [minHeap.ts](file://src/utils/minHeap.ts#L0-L114)
- [astar.ts](file://src/query/path/astar.ts#L0-L344)
- [bidirectional.ts](file://src/query/path/bidirectional.ts#L0-L301)