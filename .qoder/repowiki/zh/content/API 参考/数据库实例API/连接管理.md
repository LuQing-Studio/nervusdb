# 连接管理

<cite>
**本文档引用的文件**
- [synapseDb.ts](file://src/synapseDb.ts) - *在最近的提交中更新*
- [persistentStore.ts](file://src/storage/persistentStore.ts) - *在最近的提交中更新*
- [wal.ts](file://src/storage/wal.ts) - *在最近的提交中更新*
- [openOptions.ts](file://src/types/openOptions.ts) - *在最近的提交中更新*
- [readerRegistry.ts](file://src/storage/readerRegistry.ts) - *在最近的提交中更新*
- [pagedIndex.ts](file://src/storage/pagedIndex.ts) - *在最近的提交中更新*
- [flushManager.ts](file://src/storage/managers/flushManager.ts) - *新增文件*
- [concurrencyControl.ts](file://src/storage/managers/concurrencyControl.ts) - *在最近的提交中更新*
</cite>

## 更新摘要
**变更内容**
- 根据 `78b1bfb5` 提交，更新了 `SynapseDB.open()` 方法的实现机制，统一了数据库实例创建流程。
- 详细说明了 `PersistentStore.open()` 中路径解析、选项配置和底层文件系统交互的最新逻辑。
- 更新了 `close()` 方法的协调机制，包括刷新、文件句柄释放和读者锁清理。
- 增加了对 `FlushManager` 和 `ConcurrencyControl` 新组件的文档说明。
- 修正了因架构重构而过时的元数据加载和索引重建流程描述。

## 目录
1. [连接生命周期概述](#连接生命周期概述)
2. [打开机制详解](#打开机制详解)
3. [关闭机制详解](#关闭机制详解)
4. [高并发场景下的连接池实践](#高并发场景下的连接池实践)
5. [常见问题与解决方案](#常见问题与解决方案)

## 连接生命周期概述

SynapseDB 的连接管理围绕 `SynapseDB.open()` 和 `close()` 两个核心方法构建，形成一个完整的数据库实例生命周期。`open()` 方法负责初始化存储层、恢复未持久化状态并准备查询服务；而 `close()` 方法则确保所有写入安全落盘、释放系统资源并维护数据一致性。整个过程严格遵循原子性与安全性原则，为应用提供可靠的持久化保障。

```mermaid
graph TD
A["调用 SynapseDB.open()"] --> B{"路径解析"}
B --> C{":memory: 模式?"}
C --> |"是"| D["生成唯一临时路径"]
C --> |"否"| E["使用指定路径"]
D --> F["初始化存储结构"]
E --> F
F --> G["检查锁与WAL状态"]
G --> H["读取主文件元数据"]
H --> I["WAL日志重放"]
I --> J["重建分页索引"]
J --> K["注册读者信息"]
K --> L["返回数据库实例"]
M["调用 close()"] --> N{"存在脏数据?"}
N --> |"是"| O["执行 flush()"]
N --> |"否"| P["继续关闭流程"]
O --> P
P --> Q["关闭WAL句柄"]
Q --> R["释放写锁"]
R --> S["注销读者注册"]
S --> T["清理内存结构"]
T --> U["删除内存模式临时文件"]
U --> V["连接关闭完成"]
```

**图示来源**
- [synapseDb.ts](file://src/synapseDb.ts#L84-L108)
- [persistentStore.ts](file://src/storage/persistentStore.ts#L82-L226)
- [persistentStore.ts](file://src/storage/persistentStore.ts#L580-L625)

## 打开机制详解

### 路径解析与选项配置

`SynapseDB.open()` 方法首先接收一个路径参数和可选的 `SynapseDBOpenOptions` 配置对象。当路径为特殊值 `':memory:'` 时，系统会自动在操作系统临时目录下创建一个基于进程ID和时间戳的唯一文件路径，实现真正的内存数据库语义，并在 `close()` 时自动清理相关文件。

```mermaid
flowchart TD
Start(["开始 open()"]) --> ParsePath["解析路径参数"]
ParsePath --> MemoryMode{"路径为 ':memory:'?"}
MemoryMode --> |是| GenTemp["生成唯一临时路径"]
MemoryMode --> |否| UseGiven["使用给定路径"]
GenTemp --> InitStorage
UseGiven --> InitStorage
InitStorage --> CheckLock["检查锁文件与WAL状态"]
CheckLock --> ReadMeta["读取字典、属性等元数据"]
ReadMeta --> RebuildIndexes["决定是否重建分页索引"]
RebuildIndexes --> |是| BuildNew["调用 buildPagedIndexes()"]
RebuildIndexes --> |否| Hydrate["调用 hydratePagedReaders()"]
BuildNew --> RebuildPropertyIndex
Hydrate --> RebuildPropertyIndex
RebuildPropertyIndex --> LoadHotness["加载热度计数"]
LoadHotness --> RegisterReader["注册为活跃读者"]
RegisterReader --> ReturnInstance["返回 PersistentStore 实例"]
ReturnInstance --> End(["结束"])
```

**图示来源**
- [persistentStore.ts](file://src/storage/persistentStore.ts#L82-L226)
- [openOptions.ts](file://src/types/openOptions.ts#L5-L126)

#### 选项配置对存储层的影响

- **pageSize**: 控制每个分页索引页面包含的三元组数量，默认为1000。该值直接影响查询性能和内存占用。若现有索引的 `pageSize` 与配置不符，将触发索引重建。
- **compression**: 指定索引页面的压缩算法（`none` 或 `brotli`）及级别。此设置决定了 `PagedIndexWriter` 在写入时采用的压缩策略，影响磁盘空间利用率和I/O性能。
- **enableLock**: 当设为 `true` 时，通过 `acquireLock()` 获取文件级独占写锁，防止多个写者进程同时访问同一数据库导致数据损坏。若以无锁模式打开且检测到写锁存在且WAL非空，则拒绝访问以避免并发风险。

### 底层文件系统交互

`PersistentStore.open()` 是实际与文件系统交互的核心方法。它通过 `readStorageFile()` 从主数据库文件中解析出字典、属性等序列化部分，并利用 `initializeIfMissing()` 确保文件存在或创建空文件。

#### WAL日志恢复与元数据加载

在实例创建时，系统会执行一系列资源分配与状态恢复操作：
1.  **WAL重放**: 创建 `WalReplayer` 实例，读取 `.wal` 文件中的记录。通过校验和验证记录完整性，按 `BEGIN`/`COMMIT`/`ABORT` 事务边界处理嵌套批次，并将已提交的新增事实、删除事实及属性变更直接应用到 `PersistentStore` 的内存结构中（如 `triples`, `properties`）。
2.  **元数据加载**: 从主文件反序列化 `StringDictionary` 和 `PropertyStore`，这些构成了数据库的基础元数据。
3.  **索引重建**: 根据 `rebuildIndexes` 选项或现有 `manifest.json` 的兼容性判断，决定是调用 `buildPagedIndexes()` 全量重建所有六种排序（SPO, SOP, ...）的分页索引，还是通过 `hydratePagedReaders()` 加载现有的索引元数据。重建过程会从主文件读取历史三元组数据，确保新索引的完整性。

**章节来源**
- [persistentStore.ts](file://src/storage/persistentStore.ts#L82-L226)
- [wal.ts](file://src/storage/wal.ts#L32-L67)
- [fileHeader.ts](file://src/storage/fileHeader.ts#L129-L169)

## 关闭机制详解

`close()` 方法的设计目标是确保关闭操作的原子性与安全性，协调好写入缓冲区刷新、文件句柄释放与读者锁清理。

```mermaid
sequenceDiagram
participant App as 应用程序
participant DB as 数据库实例
participant Store as PersistentStore
participant Wal as WAL管理器
participant Lock as 并发控制器
App->>DB : 调用 close()
DB->>DB : pluginManager.cleanup()
DB->>Store : store.close()
Store->>Store : if(dirty) flush()
Store->>Store : 标记 closed = true
Store->>Wal : wal.close()
Store->>Lock : concurrencyControl.cleanup()
Lock->>Lock : releaseWriteLock()
Lock->>Lock : unregisterReader()
Store->>Store : 清理内存结构 (tombstones, transactionManager, hotness)
Store->>Store : 清理 LSM memtable
Store->>Store : 内存模式下清理临时文件
Store-->>DB : 关闭完成
DB-->>App : 连接已关闭
```

**图示来源**
- [synapseDb.ts](file://src/synapseDb.ts#L476-L479)
- [persistentStore.ts](file://src/storage/persistentStore.ts#L580-L625)
- [concurrencyControl.ts](file://src/storage/managers/concurrencyControl.ts#L23-L253)

### 刷新与资源释放

`close()` 方法首先检查是否存在未持久化的脏数据，如果存在，则调用 `flush()` 方法将其安全落盘。随后，它会关闭WAL句柄以避免文件句柄依赖垃圾回收导致的警告。接着，通过 `concurrencyControl.cleanup()` 释放写锁并注销读者注册。最后，清理所有内存结构，包括墓碑集、事务管理器和热度数据，并在内存模式下删除临时文件。

**章节来源**
- [persistentStore.ts](file://src/storage/persistentStore.ts#L580-L625)
- [flushManager.ts](file://src/storage/managers/flushManager.ts#L50-L376)

## 高并发场景下的连接池实践

在高并发场景下，应使用连接池来管理数据库连接，避免频繁打开和关闭连接带来的性能开销。建议配置合理的连接池大小，并确保每个连接在使用完毕后正确关闭，以防止资源泄漏。

**章节来源**
- [synapseDb.ts](file://src/synapseDb.ts#L62-L649)

## 常见问题与解决方案

### 未正确关闭导致的资源泄漏

- **问题**: 未调用 `close()` 方法可能导致文件句柄未释放、内存泄漏和临时文件残留。
- **解决方案**: 确保在应用程序退出前调用 `close()` 方法，或使用 `try...finally` 语句保证连接的正确关闭。

**章节来源**
- [persistentStore.ts](file://src/storage/persistentStore.ts#L580-L625)
- [synapseDb.ts](file://src/synapseDb.ts#L476-L479)