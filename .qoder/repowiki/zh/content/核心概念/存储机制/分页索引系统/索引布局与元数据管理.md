# 索引布局与元数据管理

<cite>
**本文档引用的文件**
- [pagedIndex.ts](file://src/storage/pagedIndex.ts)
- [persistentStore.ts](file://src/storage/persistentStore.ts)
</cite>

## 目录
1. [分页索引物理布局](#分页索引物理布局)
2. [PageLookup结构与索引组织](#pagelookup结构与索引组织)
3. [PagedIndexManifest元数据设计](#pagedindexmanifest元数据设计)
4. [元数据原子写入机制](#元数据原子写入机制)
5. [文件命名与目录组织](#文件命名与目录组织)
6. [索引构建与增量合并协调](#索引构建与增量合并协调)

## 分页索引物理布局

分页索引通过`PageMeta`接口定义单个页面的元数据，包含以下关键字段：

- **primaryValue**: 页面对应的主键值，用于标识该页面所存储的数据范围。
- **offset**: 页面在文件中的起始偏移量（字节），支持随机访问定位。
- **length**: 压缩后数据的实际长度（字节），用于读取指定大小的数据块。
- **rawLength**: 可选字段，表示原始未压缩数据的长度，便于解压前预分配内存。
- **crc32**: 可选但推荐使用的压缩数据CRC32校验码，确保数据完整性。

这些字段共同构成了分页索引的基础物理布局，使得系统能够高效地进行随机访问和数据验证。当执行查询时，系统根据主键值查找对应的`PageMeta`，利用`offset`和`length`直接从文件中读取相应数据块，并通过`crc32`校验数据完整性。

**Section sources**
- [pagedIndex.ts](file://src/storage/pagedIndex.ts#L7-L13)

## PageLookup结构与索引组织

`PageLookup`接口用于组织特定顺序下的所有页面索引，其结构包括：

- **order**: 索引顺序（如SPO、POS等），决定了三元组的排列方式。
- **pages**: `PageMeta`对象数组，按主键值组织的页面元数据集合。

不同顺序的`PageLookup`允许系统针对不同的查询模式优化访问路径。例如，对于以主体为主键的查询，使用SPO顺序的`PageLookup`可以快速定位相关页面。这种多顺序索引的设计提高了查询灵活性和性能。

**Section sources**
- [pagedIndex.ts](file://src/storage/pagedIndex.ts#L15-L18)

## PagedIndexManifest元数据设计

`PagedIndexManifest`是分页索引的核心元数据结构，包含以下字段：

- **version**: 版本号，用于兼容性管理。
- **pageSize**: 每页条目数量，影响索引粒度和查询效率。
- **createdAt**: 创建时间戳，用于诊断和调试。
- **compression**: 压缩选项，定义数据压缩算法和参数。
- **tombstones**: 逻辑删除的三元组ID集合，实现软删除功能。
- **epoch**: manifest版本号，用于读者可见性和运维操作。
- **orphans**: 不再被引用的旧页集合，等待垃圾回收。
- **lookups**: 各种顺序的`PageLookup`集合，构成完整的索引体系。

该结构作为分页索引的"源数据真相"，集中管理所有索引的元信息，确保系统状态的一致性和可恢复性。

**Section sources**
- [pagedIndex.ts](file://src/storage/pagedIndex.ts#L324-L333)

## 元数据原子写入机制

`writePagedManifest`函数实现了元数据的原子写入，保障一致性，具体步骤如下：

1. 在目标目录生成唯一临时文件名，避免并发写入冲突。
2. 将`PagedIndexManifest`序列化为紧凑JSON格式并写入临时文件。
3. 对临时文件执行`fsync`，确保数据持久化到磁盘。
4. 使用`rename`系统调用将临时文件重命名为最终文件名，此操作在大多数文件系统上是原子的。
5. 对父目录执行`fsync`，确保`rename`操作本身也被持久化。

这一机制结合了临时文件、原子重命名和目录同步，有效防止了因崩溃或中断导致的元数据损坏，保证了系统的可靠性。

**Section sources**
- [pagedIndex.ts](file://src/storage/pagedIndex.ts#L337-L366)

## 文件命名与目录组织

分页索引采用统一的文件命名规则和目录结构：

- **pageFileName**: 根据索引顺序生成文件名，格式为`{order}.idxpage`。
- 所有索引文件存放在独立的索引目录中，通常以主文件路径加上`.pages`后缀命名。
- 核心元数据文件`index-manifest.json`位于索引目录根部。
- 实验性LSM段文件存放在`lsm`子目录中，由`lsm-manifest.json`管理。

这种组织方式清晰分离了不同类型的数据，便于管理和维护，同时也支持高效的文件访问和备份策略。

**Section sources**
- [pagedIndex.ts](file://src/storage/pagedIndex.ts#L286-L288)

## 索引构建与增量合并协调

系统通过`buildPagedIndexes`和`appendPagedIndexesFromStaging`两个流程协调索引的构建与增量合并：

### 初始构建 (`buildPagedIndexes`)
- 遍历所有索引顺序（SPO, SOP, POS, PSO, OSP, OPS）。
- 从原始存储文件读取历史三元组数据。
- 使用`PagedIndexWriter`按主键值分页写入数据。
- 最终生成包含所有`PageLookup`的`PagedIndexManifest`。

### 增量合并 (`appendPagedIndexesFromStaging`)
- 读取现有`PagedIndexManifest`，继承配置参数。
- 结合内存暂存区（staging）和LSM段中的新数据。
- 为每个顺序创建新的页面，并追加到现有索引末尾。
- 更新`epoch`版本号，触发读者刷新。
- 若需，将`tombstones`写入新manifest。
- 清理已合并的LSM段，释放资源。

这两个流程协同工作，既保证了初始加载的完整性，又实现了增量更新的高效性，形成了一个健壮的索引管理系统。

**Section sources**
- [persistentStore.ts](file://src/storage/persistentStore.ts#L259-L314)
- [persistentStore.ts](file://src/storage/persistentStore.ts#L316-L434)