# 流式查询与执行诊断

<cite>
**本文档引用文件**  
- [06-流式查询与大结果-示例.md](file://docs/使用示例/06-流式查询与大结果-示例.md) - *已更新：新增 collect() 与 explain 诊断说明*  
- [附录-API-查询与惰性执行.md](file://docs/教学文档/附录-API-查询与惰性执行.md) - *已更新：补充 FOLLOW_PATH 与基数估算细节*  
- [queryBuilder.ts](file://src/query/queryBuilder.ts) - *核心惰性执行与流式查询逻辑*  
- [synapseDb.ts](file://src/synapseDb.ts) - *findLazy 与 findStreaming 接口定义*  
</cite>

## 更新摘要
**变更内容**  
- 新增 `collect()` 异步收集方法的使用说明与性能对比  
- 详细解析 `explain()` 返回的基数估算字段（`upperBound`, `hotnessPrimary`, `estimatedOutput`）  
- 补充 `FOLLOW_PATH` 执行计划的流式扩展机制与去重策略  
- 增加 `variablePathStream` 的使用场景与 BFS 层序遍历说明  
- 强化 `TRACE` 诊断日志的启用方式与输出解读  
- 更新 `all()` 与 `collect()` 的内存行为对比  

## 目录
- 惰性执行模型
- FOLLOW_PATH 执行计划
- 基数估算详解
- TRACE 执行诊断
- `collect()` 与 `all()` 对比
- `variablePathStream` 使用场景
- 性能调优建议
- 典型问题排查

## 惰性执行模型
惰性执行模型是流式查询的核心，通过延迟物化结果集来避免大内存占用。`find()` 默认返回 `LazyQueryBuilder`，仅在执行阶段（如 `collect()`、`batch()`）逐步产出数据。

```ts
// 惰性链构建阶段不物化
const lazyQuery = db.find({ predicate: 'FRIEND_OF' })
  .whereProperty('since', '>=', 2020, 'edge')
  .follow('WORKS_AT');

// 执行阶段才开始流式处理
for await (const batch of lazyQuery.batch(500)) {
  console.log(`处理批次，大小: ${batch.length}`);
}
```

在 `withSnapshot` 回调中，为保证快照一致性，`find()` 会回落为“即刻物化”，此时应优先使用 `findLazy()` 保持流式行为。

**Section sources**  
- [synapseDb.ts](file://src/synapseDb.ts#L200-L215) - *find() 与 findLazy() 实现*  
- [queryBuilder.ts](file://src/query/queryBuilder.ts#L979-L1050) - *LazyQueryBuilder 构造逻辑*  

## FOLLOW_PATH 执行计划
`followPath()` 在惰性执行模式下采用 `FOLLOW_PATH` 计划，实现真正的流式层序扩展（BFS）。该计划在执行期按深度逐层扩展，前沿节点与边自动去重，保证顺序稳定。

```ts
// FOLLOW_PATH 计划：流式产出 depth ∈ [min..max] 的“最后一跳”边
const pathQuery = db.find({ subject: 'Alice' })
  .followPath('FRIEND_OF', { min: 1, max: 3 }, { direction: 'forward' });

for await (const edge of pathQuery) {
  console.log(`路径边: ${edge.subject} -> ${edge.object}`);
}
```

执行过程：
1. 从初始前沿（如 'Alice' 节点）开始
2. 按层（depth）扩展，每层使用 `streamFactRecords` 批量读取
3. 使用 `visited` 集合对节点去重，`seenTriple` 集合对边去重
4. 当 `depth >= min` 时，产出“最后一跳”边

**Section sources**  
- [queryBuilder.ts](file://src/query/queryBuilder.ts#L1776-L1899) - *FOLLOW_PATH 流式实现*  
- [synapseDb.ts](file://src/synapseDb.ts#L200) - *find() 返回 LazyQueryBuilder*  

## 基数估算详解
`explain()` 方法提供执行计划的基数估算，帮助预判查询性能。关键估算字段包括：

- **`order`**: 选用的六序索引（如 `SPO`），决定主维度扫描顺序
- **`upperBound`**: 基于主维度页覆盖的上界（保守估计），计算方式为 `命中的页数 × 页大小`
- **`hotnessPrimary`**: 主维度（值）热度合并计数，合并对偶顺序（如 `SPO` 与 `SOP`）的热度计数，反映数据访问频率
- **`estimatedOutput`**: 传播后的粗略输出量，考虑 `FOLLOW` 倍增、`skip`/`limit`、`union` 等操作的影响

```ts
const explainResult = db.find({ predicate: 'FRIEND_OF' })
  .follow('LIVES_IN')
  .explain();

console.log(explainResult.estimate);
// 输出示例:
// {
//   order: 'SPO',
//   upperBound: 10240,        // 保守上界
//   hotnessPrimary: 150,      // 主维度热度
//   estimatedOutput: 7500     // 传播后预估输出
// }
```

**Section sources**  
- [queryBuilder.ts](file://src/query/queryBuilder.ts#L1150-L1350) - *explain() 估算逻辑*  
- [06-流式查询与大结果-示例.md](file://docs/使用示例/06-流式查询与大结果-示例.md#L70-L75) - *环境变量说明*  

## TRACE 执行诊断
启用 `SYNAPSEDB_TRACE_QUERY=1` 环境变量后，`LazyQueryBuilder` 在执行阶段会输出各 `stage` 的耗时与计数，用于性能诊断。

```bash
# 启用 TRACE 日志
SYNAPSEDB_TRACE_QUERY=1 node your-script.js
```

输出示例：
```
[TRACE] stage=FIND count=1000 costMs=15
[TRACE] stage=FOLLOW count=5000 costMs=42
[TRACE] stage=LIMIT count=100 costMs=1
```

每个 `stage` 对应查询计划中的一个操作（如 `FIND`, `FOLLOW`, `WHERE_PROP`），`count` 表示该阶段产出的记录数，`costMs` 为耗时（毫秒）。

**Section sources**  
- [queryBuilder.ts](file://src/query/queryBuilder.ts#L1550-L1570) - *traceWrap 包装器实现*  
- [附录-API-查询与惰性执行.md](file://docs/教学文档/附录-API-查询与惰性执行.md#L60-L62) - *环境变量说明*  

## `collect()` 与 `all()` 对比
| 特性 | `collect()` | `all()` |
|------|-----------|--------|
| **执行模型** | 真·流式异步收集 | 同步物化，一次性加载 |
| **内存占用** | 低，逐步收集 | 高，需容纳全部结果 |
| **返回类型** | `Promise<FactRecord[]>` | `FactRecord[]` |
| **适用场景** | 大结果集，避免内存峰值 | 小结果集，需要立即使用数组 |

```ts
// 推荐：使用 collect() 处理大结果
const largeResult = await db.find({ predicate: 'FRIEND_OF' }).limit(10000).collect();

// 警告：all() 可能导致内存溢出
// const largeResult = db.find({ predicate: 'FRIEND_OF' }).limit(10000).all(); // 不推荐
```

**Section sources**  
- [queryBuilder.ts](file://src/query/queryBuilder.ts#L1450-L1470) - *collect() 实现*  
- [queryBuilder.ts](file://src/query/queryBuilder.ts#L150-L160) - *all() 实现*  

## `variablePathStream` 使用场景
`variablePathStream` 提供真正的流式变长路径查询，采用层序 BFS 遍历，满足跳数范围与唯一性约束，逐条产出路径结果。

```ts
// 真流式变长路径：逐条产出路径
for await (const path of db.find({ subject: 'Alice' })
  .variablePathStream('FRIEND_OF', { min: 1, max: 3 }, { uniqueness: 'NODE' })) {
  console.log(`路径长度: ${path.length}, 边数: ${path.edges.length}`);
}
```

**适用场景**：
- 大范围路径查询（`max` 较大），避免内存爆炸
- 需要实时处理路径结果（如流式输出到前端）
- 结合 `limit()` 控制消费速率

**Section sources**  
- [queryBuilder.ts](file://src/query/queryBuilder.ts#L1900-L1941) - *variablePathStream 实现*  
- [06-流式查询与大结果-示例.md](file://docs/使用示例/06-流式查询与大结果-示例.md#L30-L35) - *variablePathStream 示例*  

## 性能调优建议
1. **优先使用结构化过滤**：用 `whereProperty()`/`whereLabel()` 替代 `where()`，避免内存全扫描
2. **合理设置批次大小**：`batch(n)` 的 `n` 过大导致内存上涨，过小增加 I/O 开销，建议 256~1024
3. **利用基数估算**：通过 `explain()` 预判 `upperBound` 和 `estimatedOutput`，避免执行超大查询
4. **控制路径范围**：`followPath` 和 `variablePathStream` 的 `max` 不宜过大，配合 `uniqueness` 与 `limit` 使用
5. **启用 TRACE 诊断**：定位性能瓶颈阶段（如 `FIND` 或 `FOLLOW` 耗时过长）

## 典型问题排查
| 现象 | 原因 | 解决方案 |
|------|------|----------|
| 内存持续上涨 | 使用 `all()` 或大批次 `batch()` | 改用 `collect()` 或减小 `batchSize` |
| 查询速度慢 | I/O 瓶颈或计划不佳 | 检查 `TRACE` 日志，优化过滤条件，确保使用合适索引 |
| 查询结果不完整 | `FOLLOW_PATH` 去重导致 | 确认是否需要重复路径，调整 `uniqueness` 策略 |
| `explain` 估算偏差大 | 热度数据未更新或统计信息陈旧 | 执行 `maintenance` 操作更新统计信息 |