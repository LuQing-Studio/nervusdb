/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface OpenOptions {
  dataPath: string
}
export interface TripleOutput {
  subjectId: bigint
  predicateId: bigint
  objectId: bigint
}
export interface TripleInput {
  subjectId: bigint
  predicateId: bigint
  objectId: bigint
}
export interface QueryCriteriaInput {
  subjectId?: bigint
  predicateId?: bigint
  objectId?: bigint
}
export interface CursorId {
  id: bigint
}
export interface CursorBatch {
  triples: Array<TripleOutput>
  done: boolean
}
export interface FactOutput {
  subject: string
  predicate: string
  object: string
  subjectId: bigint
  predicateId: bigint
  objectId: bigint
}
export interface FactCursorBatch {
  facts: Array<FactOutput>
  done: boolean
}
export interface PathResultOutput {
  path: Array<bigint>
  cost: number
  hops: number
}
export interface PageRankEntryOutput {
  nodeId: bigint
  score: number
}
export interface PageRankResultOutput {
  scores: Array<PageRankEntryOutput>
  iterations: number
  converged: boolean
}
export interface TimelineQueryInput {
  entityId: string
  predicateKey?: string
  role?: string
  asOf?: string
  betweenStart?: string
  betweenEnd?: string
}
export interface TimelineFactOutput {
  factId: string
  subjectEntityId: string
  predicateKey: string
  objectEntityId?: string
  objectValue?: string
  validFrom: string
  validTo?: string
  confidence: number
  sourceEpisodeId: string
}
export interface TimelineEpisodeOutput {
  episodeId: string
  sourceType: string
  payload: string
  occurredAt: string
  ingestedAt: string
  traceHash: string
}
export interface TemporalEpisodeInput {
  sourceType: string
  payloadJson: string
  occurredAt: string
  traceHash?: string
}
export interface TemporalEnsureEntityInput {
  kind: string
  canonicalName: string
  alias?: string
  confidence?: number
  occurredAt?: string
  versionIncrement?: boolean
}
export interface TemporalEntityOutput {
  entityId: string
  kind: string
  canonicalName: string
  fingerprint: string
  firstSeen: string
  lastSeen: string
  version: string
}
export interface TemporalFactWriteInput {
  subjectEntityId: string
  predicateKey: string
  objectEntityId?: string
  objectValueJson?: string
  validFrom?: string
  validTo?: string
  confidence?: number
  sourceEpisodeId: string
}
export interface TemporalLinkInput {
  episodeId: string
  entityId?: string
  factId?: string
  role: string
}
export interface TemporalLinkOutput {
  linkId: string
  episodeId: string
  entityId?: string
  factId?: string
  role: string
}
export declare function open(options: OpenOptions): NapiResult
export declare class DatabaseHandle {
  temporalAddEpisode(input: TemporalEpisodeInput): NapiResult
  temporalEnsureEntity(input: TemporalEnsureEntityInput): NapiResult
  temporalUpsertFact(input: TemporalFactWriteInput): NapiResult
  temporalLinkEpisode(input: TemporalLinkInput): NapiResult
  temporalListEntities(): NapiResult
  temporalListEpisodes(): NapiResult
  temporalListFacts(): NapiResult
  addFact(subject: string, predicate: string, object: string): NapiResult
  deleteFact(subject: string, predicate: string, object: string): NapiResult
  batchAddFacts(triples: Array<TripleInput>): NapiResult
  batchDeleteFacts(triples: Array<TripleInput>): NapiResult
  intern(value: string): NapiResult
  resolveId(value: string): NapiResult
  resolveStr(id: bigint): NapiResult
  getDictionarySize(): NapiResult
  executeQuery(query: string, params?: object | undefined | null): NapiResult
  setNodeProperty(nodeId: bigint, json: string): NapiResult
  getNodeProperty(nodeId: bigint): NapiResult
  setEdgeProperty(subjectId: bigint, predicateId: bigint, objectId: bigint, json: string): NapiResult
  getEdgeProperty(subjectId: bigint, predicateId: bigint, objectId: bigint): NapiResult
  query(criteria?: QueryCriteriaInput | undefined | null): NapiResult
  queryFacts(criteria?: QueryCriteriaInput | undefined | null): NapiResult
  timelineQuery(input: TimelineQueryInput): NapiResult
  timelineTrace(factId: string): NapiResult
  hydrate(dictionary: Array<string>, triples: Array<TripleInput>): NapiResult
  openCursor(criteria?: QueryCriteriaInput | undefined | null): NapiResult
  readCursor(cursorId: bigint, batchSize: number): NapiResult
  readCursorFacts(cursorId: bigint, batchSize: number): NapiResult
  closeCursor(cursorId: bigint): NapiResult
  beginTransaction(): NapiResult
  commitTransaction(): NapiResult
  abortTransaction(): NapiResult
  close(): NapiResult
  /** BFS shortest path (unweighted) */
  bfsShortestPath(startId: bigint, endId: bigint, predicateId?: bigint | undefined | null, maxHops?: number | undefined | null, bidirectional?: boolean | undefined | null): NapiResult
  /** Dijkstra shortest path (weighted, uniform weight = 1.0) */
  dijkstraShortestPath(startId: bigint, endId: bigint, predicateId?: bigint | undefined | null, maxHops?: number | undefined | null): NapiResult
  /** PageRank algorithm */
  pagerank(predicateId?: bigint | undefined | null, damping?: number | undefined | null, maxIterations?: number | undefined | null, tolerance?: number | undefined | null): NapiResult
}
